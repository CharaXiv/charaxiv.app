package components

import (
	"charaxiv/templates/icons"
	"fmt"
	"strconv"
)

var numberInputStyles = templ.NewOnceHandle()
var numberInputScript = templ.NewOnceHandle()

// NumberInputConfig holds configuration for a number input
type NumberInputConfig struct {
	ID          string
	Name        string
	Value       int
	Min         *int // nil means no minimum
	Max         *int // nil means no maximum
	Placeholder string
	Readonly    bool
	HxPost      string // Base path for adjust endpoint (e.g., "/api/skill/回避/job/adjust"), defaults to "/api/status/{ID}/adjust"
	HxTarget    string // Target selector, defaults to self ("#{ID}-wrapper")
	HxSwap      string // Swap strategy, defaults to "outerHTML". Use "none" for OOB-only responses.
}

// Ptr is a generic helper to create a pointer to any value
func Ptr[T any](v T) *T {
	return &v
}

// Helper methods for checking limits
func (c NumberInputConfig) hasMin() bool { return c.Min != nil }
func (c NumberInputConfig) hasMax() bool { return c.Max != nil }
func (c NumberInputConfig) minVal() int {
	if c.Min != nil {
		return *c.Min
	}
	return 0
}
func (c NumberInputConfig) maxVal() int {
	if c.Max != nil {
		return *c.Max
	}
	return 0
}
func (c NumberInputConfig) atMin() bool { return c.Min != nil && c.Value <= *c.Min }
func (c NumberInputConfig) atMax() bool { return c.Max != nil && c.Value >= *c.Max }

// adjustPath returns the base path for the adjust endpoint
func (c NumberInputConfig) adjustPath() string {
	if c.HxPost != "" {
		return c.HxPost
	}
	return fmt.Sprintf("/api/status/%s/adjust", c.ID)
}

// targetSelector returns the hx-target selector
func (c NumberInputConfig) targetSelector() string {
	if c.HxTarget != "" {
		return c.HxTarget
	}
	return "#" + c.ID + "-wrapper"
}

// swapStrategy returns the hx-swap value
func (c NumberInputConfig) swapStrategy() string {
	if c.HxSwap != "" {
		return c.HxSwap
	}
	return "outerHTML"
}

// NumberInput renders a number input with ±1 and ±5 buttons
templ NumberInput(cfg NumberInputConfig) {
	@numberInputStyles.Once() {
		<style>
			.number-input {
				display: flex;
				flex-direction: row;
				align-items: center;
				height: 32px;
				width: 100%;
			}

			.number-input-field {
				flex: 1;
				height: 100%;
				min-width: 0;
				padding: 0 var(--space-1);
				border: none;
				background: transparent;
				font-size: var(--font-size-base);
				font-weight: var(--font-weight-semibold);
				text-align: center;
				outline: none;
				touch-action: manipulation;
			}

			.number-input-field::placeholder {
				font-weight: var(--font-weight-semibold);
				color: var(--slate-300);
			}

			.number-input-btn {
				flex-shrink: 0;
				width: 28px;
				height: 28px;
				display: inline-flex;
				align-items: center;
				justify-content: center;
				border: none;
				background: transparent;
				color: var(--slate-400);
				border-radius: var(--radius-sm);
				cursor: pointer;
				transition: var(--transition-fast);
				touch-action: manipulation;
			}

			.number-input-btn:hover:not(:disabled) {
				background: var(--slate-100);
				color: var(--slate-600);
			}

			.number-input-btn:disabled {
				color: var(--slate-200);
				cursor: not-allowed;
			}

			.number-input-btn .icon {
				width: 12px;
				height: 12px;
			}
		</style>
	}
	@numberInputScript.Once() {
		<script>
			function adjustNumberInput(btn, delta) {
				const wrapper = btn.parentNode;
				const input = wrapper.querySelector('input');
				const value = parseInt(input.value) || 0;
				const min = parseInt(input.min);
				const max = parseInt(input.max);
				const newValue = Math.max(min, Math.min(max, value + delta));
				input.value = newValue;

				wrapper.querySelectorAll('button').forEach(b => {
					const d = parseInt(b.title);
					b.disabled = (d < 0 && newValue <= min) || (d > 0 && newValue >= max);
				});
			}
		</script>
	}
	<div class="number-input" id={ cfg.ID + "-wrapper" }>
		<button
			type="button"
			class="number-input-btn"
			title="-5"
			disabled?={ cfg.Readonly || cfg.atMin() }
			hx-on::before-request="adjustNumberInput(this, -5)"
			hx-post={ cfg.adjustPath() + "?delta=-5" }
			hx-target={ cfg.targetSelector() }
			hx-swap={ cfg.swapStrategy() }
		>
			@icons.IconAnglesLeft()
		</button>
		<button
			type="button"
			class="number-input-btn"
			title="-1"
			disabled?={ cfg.Readonly || cfg.atMin() }
			hx-on::before-request="adjustNumberInput(this, -1)"
			hx-post={ cfg.adjustPath() + "?delta=-1" }
			hx-target={ cfg.targetSelector() }
			hx-swap={ cfg.swapStrategy() }
		>
			@icons.IconAngleLeft()
		</button>
		<input
			type="number"
			class="number-input-field"
			id={ cfg.ID }
			name={ cfg.Name }
			value={ strconv.Itoa(cfg.Value) }
			placeholder={ cfg.Placeholder }
			if cfg.hasMin() {
				min={ strconv.Itoa(cfg.minVal()) }
			}
			if cfg.hasMax() {
				max={ strconv.Itoa(cfg.maxVal()) }
			}
			readonly?={ cfg.Readonly }
			if !cfg.Readonly {
				hx-post={ fmt.Sprintf("/api/status/%s/set", cfg.ID) }
				hx-trigger="input changed delay:3000ms"
				hx-include="this"
			}
		/>
		<button
			type="button"
			class="number-input-btn"
			title="+1"
			disabled?={ cfg.Readonly || cfg.atMax() }
			hx-on::before-request="adjustNumberInput(this, 1)"
			hx-post={ cfg.adjustPath() + "?delta=1" }
			hx-target={ cfg.targetSelector() }
			hx-swap={ cfg.swapStrategy() }
		>
			@icons.IconAngleRight()
		</button>
		<button
			type="button"
			class="number-input-btn"
			title="+5"
			disabled?={ cfg.Readonly || cfg.atMax() }
			hx-on::before-request="adjustNumberInput(this, 5)"
			hx-post={ cfg.adjustPath() + "?delta=5" }
			hx-target={ cfg.targetSelector() }
			hx-swap={ cfg.swapStrategy() }
		>
			@icons.IconAnglesRight()
		</button>
	</div>
}

// TextInputConfig holds configuration for a text input
type TextInputConfig struct {
	ID          string
	Name        string
	Value       string
	Placeholder string
	Readonly    bool
	Center      bool
}

var textInputStyles = templ.NewOnceHandle()

// TextInput renders a styled text input
templ TextInput(cfg TextInputConfig) {
	@textInputStyles.Once() {
		<style>
			.text-input {
				width: 100%;
				height: 32px;
				padding: 0 var(--space-2);
				border: 1px solid var(--slate-200);
				border-radius: var(--radius-md);
				font-size: var(--font-size-base);
				font-weight: var(--font-weight-semibold);
				outline: none;
				transition: var(--transition-fast);
				background: var(--white);
			}

			.text-input:hover:not(:disabled):not(:read-only) {
				border-color: var(--slate-300);
			}

			.text-input:focus {
				border-color: var(--blue-500);
			}

			.text-input::placeholder {
				color: var(--slate-400);
				font-weight: var(--font-weight-semibold);
			}

			.text-input--center {
				text-align: center;
			}
		</style>
	}
	<input
		type="text"
		class={ "text-input", templ.KV("text-input--center", cfg.Center) }
		id={ cfg.ID }
		name={ cfg.Name }
		value={ cfg.Value }
		placeholder={ cfg.Placeholder }
		if cfg.Readonly {
			readonly
		}
	/>
}

// ProfileInputSize represents the size variant for profile inputs
type ProfileInputSize string

const (
	ProfileInputName ProfileInputSize = "name"
	ProfileInputRuby ProfileInputSize = "ruby"
)

// ProfileInputConfig holds configuration for a profile text input
type ProfileInputConfig struct {
	ID          string
	Name        string
	Value       string
	Placeholder string
	Readonly    bool
	Size        ProfileInputSize
}

var profileInputStyles = templ.NewOnceHandle()

// ProfileInput renders an inline-editable profile text input (for name/ruby)
templ ProfileInput(cfg ProfileInputConfig) {
	@profileInputStyles.Once() {
		<style>
			.profile-input {
				width: 100%;
				border: none;
				outline: none;
				background: transparent;
				border-radius: var(--radius-md);
				transition: background var(--transition-fast);
			}

			.profile-input:hover:not(:read-only) {
				background: var(--slate-100);
			}

			.profile-input--name {
				height: 40px;
				font-size: var(--font-size-4xl);
				font-weight: var(--font-weight-semibold);
				line-height: 40px;
				color: var(--blue-600);
			}

			.profile-input--name::placeholder {
				font-size: var(--font-size-4xl);
				font-weight: var(--font-weight-semibold);
				color: var(--slate-300);
			}

			.profile-input--ruby {
				height: 28px;
				font-size: var(--font-size-lg);
				line-height: 28px;
				color: var(--slate-500);
			}

			.profile-input--ruby::placeholder {
				font-size: var(--font-size-lg);
				color: var(--slate-300);
			}
		</style>
	}
	<input
		type="text"
		class={ "profile-input", "profile-input--" + string(cfg.Size) }
		id={ cfg.ID }
		name={ cfg.Name }
		value={ cfg.Value }
		placeholder={ cfg.Placeholder }
		if cfg.Readonly {
			readonly
		}
	/>
}
