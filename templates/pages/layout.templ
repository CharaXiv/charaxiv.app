package pages

import (
	"charaxiv/templates/components"
	"os"
)

func isDev() bool {
	return os.Getenv("DEV") == "1"
}

templ layoutStyles() {
	<style>
		/* Mobile: padding at bottom for fixed header */
		.header-padding-bottom {
			height: 48px;
			background: white;
		}

		/* Desktop: no bottom padding needed (header is sticky) */
		@media (min-width: 640px) {
			.header-padding-bottom {
				display: none;
			}
		}
	</style>
}

// Layout renders the base HTML structure.
// headerActions: content for the header actions area (buttons)
// content: main page content
templ Layout(title string, headerActions templ.Component, content templ.Component) {
	<!DOCTYPE html>
	<html lang="en">
		<head>
			<meta charset="UTF-8"/>
			<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
			<title>{ title } - CharaXiv</title>
			<script src="https://unpkg.com/htmx.org@2.0.4" defer></script>
			<script src="https://unpkg.com/idiomorph@0.7.4/dist/idiomorph-ext.min.js" defer></script>
		</head>
		<body hx-ext="morph">
			@components.DesignSystem()
			@layoutStyles()
			@components.Header() {
				if headerActions != nil {
					@headerActions
				}
			}
			<main>
				@content
			</main>
			<div class="header-padding-bottom"></div>
			if isDev() {
				@liveReloadScript()
			}
		</body>
	</html>
}

templ liveReloadScript() {
	<style>
		#live-reload-indicator {
			position: fixed;
			bottom: 8px;
			right: 8px;
			z-index: 99999;
			display: flex;
			align-items: center;
			gap: 6px;
			padding: 4px 8px;
			border-radius: 4px;
			font-size: 11px;
			font-family: system-ui, sans-serif;
			background: rgba(0, 0, 0, 0.7);
			color: white;
			transition: opacity 0.3s;
			pointer-events: none;
		}
		#live-reload-indicator.hidden {
			opacity: 0;
		}
		#live-reload-indicator .dot {
			width: 8px;
			height: 8px;
			border-radius: 50%;
			background: currentColor;
		}
		#live-reload-indicator.connected { color: #4ade80; }
		#live-reload-indicator.reconnecting { color: #facc15; }
		#live-reload-indicator.failed { color: #f87171; }
		#live-reload-indicator.reconnecting .dot {
			animation: pulse 1s infinite;
		}
		@keyframes pulse {
			0%, 100% { opacity: 1; }
			50% { opacity: 0.3; }
		}
	</style>
	<div id="live-reload-indicator" class="hidden">
		<span class="dot"></span>
		<span class="status">Connecting...</span>
	</div>
	<script>
		(function() {
			const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
			const wsUrl = protocol + '//' + location.host + '/dev/subscribe';
			
			// State
			let ws = null;
			let connected = false;
			let currentBuildID = null;
			let pendingBuildID = null;
			let reconnectAttempts = 0;
			let lastHeartbeat = Date.now();
			let heartbeatCheckInterval = null;
			let reconnectTimeout = null;
			let hideIndicatorTimeout = null;
			let stableReloadTimeout = null;
			
			// Config
			const MAX_RECONNECT_ATTEMPTS = 60;
			const HEARTBEAT_TIMEOUT_MS = 15000; // Expect heartbeat every 5s, timeout after 15s
			const BASE_RECONNECT_DELAY_MS = 100;
			const MAX_RECONNECT_DELAY_MS = 5000;
			const STABLE_DELAY_MS = 500; // Wait for server to be stable before reloading
			
			// UI
			const indicator = document.getElementById('live-reload-indicator');
			const statusText = indicator.querySelector('.status');
			
			function setStatus(state, text, autoHide = false) {
				indicator.className = state;
				statusText.textContent = text;
				
				if (hideIndicatorTimeout) {
					clearTimeout(hideIndicatorTimeout);
					hideIndicatorTimeout = null;
				}
				
				if (autoHide) {
					hideIndicatorTimeout = setTimeout(() => {
						indicator.classList.add('hidden');
					}, 2000);
				}
			}
			
			function getReconnectDelay() {
				// Exponential backoff with jitter
				const exponentialDelay = Math.min(
					BASE_RECONNECT_DELAY_MS * Math.pow(2, reconnectAttempts),
					MAX_RECONNECT_DELAY_MS
				);
				// Add jitter: Â±25%
				const jitter = exponentialDelay * 0.25 * (Math.random() * 2 - 1);
				return Math.round(exponentialDelay + jitter);
			}
			
			function startHeartbeatCheck() {
				stopHeartbeatCheck();
				lastHeartbeat = Date.now();
				heartbeatCheckInterval = setInterval(() => {
					if (Date.now() - lastHeartbeat > HEARTBEAT_TIMEOUT_MS) {
						console.log('[LiveReload] Heartbeat timeout, reconnecting...');
						if (ws) {
							ws.close();
						}
					}
				}, 5000);
			}
			
			function stopHeartbeatCheck() {
				if (heartbeatCheckInterval) {
					clearInterval(heartbeatCheckInterval);
					heartbeatCheckInterval = null;
				}
			}
			
			function cancelPendingReload() {
				if (stableReloadTimeout) {
					clearTimeout(stableReloadTimeout);
					stableReloadTimeout = null;
					console.log('[LiveReload] Pending reload cancelled (connection lost)');
				}
			}
			
			function scheduleStableReload(buildID) {
				// Cancel any existing pending reload
				if (stableReloadTimeout) {
					clearTimeout(stableReloadTimeout);
				}
				
				// Track the latest build ID we want to reload to
				pendingBuildID = buildID;
				
				setStatus('reconnecting', 'Waiting for stable server...');
				console.log(`[LiveReload] Scheduling reload to build ${buildID} in ${STABLE_DELAY_MS}ms`);
				
				stableReloadTimeout = setTimeout(() => {
					if (connected && pendingBuildID !== null) {
						console.log('[LiveReload] Server stable, reloading to build:', pendingBuildID);
						location.reload();
					}
				}, STABLE_DELAY_MS);
			}
			
			function scheduleReconnect() {
				if (reconnectTimeout) {
					clearTimeout(reconnectTimeout);
				}
				
				// Cancel pending reload since connection is lost
				cancelPendingReload();
				
				if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
					setStatus('failed', 'Connection failed');
					console.log('[LiveReload] Max reconnection attempts reached');
					return;
				}
				
				const delay = getReconnectDelay();
				reconnectAttempts++;
				
				setStatus('reconnecting', `Reconnecting (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})...`);
				console.log(`[LiveReload] Reconnecting in ${delay}ms (attempt ${reconnectAttempts})`);
				
				reconnectTimeout = setTimeout(connect, delay);
			}
			
			function connect() {
				if (ws && (ws.readyState === WebSocket.CONNECTING || ws.readyState === WebSocket.OPEN)) {
					return; // Already connecting/connected
				}
				
				console.log('[LiveReload] Connecting to', wsUrl);
				setStatus('reconnecting', 'Connecting...');
				
				ws = new WebSocket(wsUrl);
				
				ws.onopen = function() {
					console.log('[LiveReload] Connected');
					connected = true;
					reconnectAttempts = 0; // Reset on successful connection
					startHeartbeatCheck();
					// Don't auto-hide if we have a pending reload
					if (!pendingBuildID) {
						setStatus('connected', 'Live reload active', true);
					}
				};
				
				ws.onmessage = function(event) {
					const data = event.data;
					
					if (data === 'heartbeat') {
						lastHeartbeat = Date.now();
						return;
					}
					
					if (data.startsWith('build:')) {
						const serverBuildID = parseInt(data.slice(6), 10);
						lastHeartbeat = Date.now();
						
						if (currentBuildID === null) {
							// First connection, just record the build ID
							currentBuildID = serverBuildID;
							console.log('[LiveReload] Initial build ID:', currentBuildID);
							setStatus('connected', 'Live reload active', true);
						} else if (serverBuildID > currentBuildID) {
							// Server has newer build, schedule reload after stability check
							console.log('[LiveReload] Build ID changed:', currentBuildID, '->', serverBuildID);
							scheduleStableReload(serverBuildID);
						} else if (pendingBuildID !== null && serverBuildID >= pendingBuildID) {
							// We reconnected and server still has the build we want
							console.log('[LiveReload] Reconnected, resuming reload to build:', serverBuildID);
							scheduleStableReload(serverBuildID);
						} else {
							// Same or older build, clear pending
							pendingBuildID = null;
							setStatus('connected', 'Live reload active', true);
						}
						return;
					}
					
					if (data.startsWith('reload:')) {
						const newBuildID = parseInt(data.slice(7), 10);
						console.log('[LiveReload] Reload signal received, build:', newBuildID);
						scheduleStableReload(newBuildID);
						return;
					}
				};
				
				ws.onclose = function(event) {
					stopHeartbeatCheck();
					
					if (connected) {
						console.log('[LiveReload] Connection lost, will reconnect...');
						connected = false;
					}
					
					scheduleReconnect();
				};
				
				ws.onerror = function(error) {
					// Error will trigger onclose
					console.log('[LiveReload] WebSocket error');
				};
			}
			
			// Start connection
			connect();
		})();
	</script>
}
